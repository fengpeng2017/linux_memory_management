出处： http://coderbee.net/index.php/io/20131223/666/comment-page-1
1.缓冲区操作：
缓冲区以及缓冲区是如何工作的，是所有I/O的基础，“输入/输出”就是把数据移入或者移出缓冲区。
进程执行I/O操作就是向操作系统发出请求，让它要么把缓冲区的数据排干（写），要么用数据把缓冲区填满（读）。进程使用这一机制
处理所有数据进出操作。
从磁盘读数据到进程内存区：
图见  http://coderbee.net/index.php/io/20131223/666/comment-page-1
进程使用 read( ) 系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接
写入内核内存缓冲区，这一步通过DMA完成，无需主CPU 协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝
到进程执行 read( ) 调用时指定的缓冲区。

用户空间与内核空间
用户空间：用户空间是常规进程所在区域，是非特权区域，比如该区域的代码不能直接访问硬件设备。
内核空间：内核空间是操作系统所在区域，有特别的权利：能与设备控制器通讯，控制用户区域进程的运行状态等等.

所有I/O都直接或间接通过内核空间，通过请求页面调度完成。
当进程请求I/O操作的时候，它执行一个系统调用将控制权移交给内核。内核随即采取必要步骤，找到进程所需数据，并把数据传送到用户
空间内指定的缓冲区。如果数据已在内核空间，直接拷贝即可；如果不在内核空间，则进程被挂起，内核着手把数据读进内存。

虚拟内存
虚拟内存意为使用虚假（或虚拟）地址取代物理（硬件RAM）内存地址，好处有两大类：
一个以上的虚拟地址可指向同一个物理内存地址。
虚拟内存空间可大于实际可用的硬件内存。

由于设备控制器不能通过DMA直接存储到用户空间，但通过把内核空间地址和用户空间的虚拟地址映射到同一个物理地址，这样，DMA硬件
（只能访问物理内存地址）就可以填充对内核与用户空间进程同时可见的缓冲区。

内存空间多重映射： 省去了内核与用户空间的来往拷贝，前提是，内核与用户缓冲区必须使用相同的页对齐，缓冲区的大小还必须是磁盘
控制器块大小的倍数。
操作系统把内存地址空间划分为页，及固定大小的字节组。内存页的大小总是磁盘块大小的倍数，通常是2次幂（可简化寻址操作）。

内存页面调度
为了支持虚拟内存寻址空间大于物理内存，必须进行虚拟内存分页（一般称为交换，真正的交换是在进程层面完成，非页面层面）。对于
暂时不用的内存页放到外部磁盘存储，为物理内存中的其他虚拟页腾出空间。本质上，物理内存充当了分页区的高速缓存；分页区就是从
物理内存置换出来，存储在磁盘上的内存页面。

现代CPU包含一个内存管理单元（MMU）的子系统，逻辑上位于 CPU与物理内存之间。该设备包含了虚拟地址向物理内存地址转换时所需映
射信息。当CPU引用某内存地址时，MMU负责确定该地址所在页（通常通过对地址进行移位和屏蔽位操作来实现），并将虚拟页号转换为物
理页号（由硬件完成，速度极快）。如果当前不存在与该虚拟页形成有效映射的物理内存页，MMU向CPU提交一个页错误。

页错误随即产生一个陷阱（类似于系统调用），把控制权移交给内核，附带导致错误的虚拟地址信息，然后内核采取步骤验证页的有效性
。内核会安排页面调入操作，把缺失的页内容读回物理内存。这往往导致别的页被移出物理内存，好给新来的页让地方。在这种情况下，
如果待移出的页已经被碰过了（自创建或上次页面调入以来，内容已发生改变），还必须首先执行页面调出，把页内容拷贝到磁盘上的分
页区。

如果所要求的地址不是有效的虚拟内存地址（不属于正在执行的进程的任何一个内存段），则该页不能通过验证，段错误随即产生。于是，
控制权转交给内核的另一部分，通常导致的结果就是进程被强令关闭。
一旦出错的页通过了验证，MMU 随即更新，建立新的虚拟到物理的映射（如有必要，中断被移出页的映射），用户进程得以继续。造成页
错误的用户进程对此不会有丝毫察觉，一切都在不知不觉中进行。

文件I/O：
文件系统把一连串大小一致的数据块组织到一起。有些块存储元信息，如空闲块、目录、索引等的映射，有些包含文件数据。单个文件的
元信息描述了哪些块包含文件数据、数据在哪里结束、最后一次更新是什么时候，等等。

采用分页技术的操作系统执行I/O的全过程可总结为如下步骤：
确定请求的数据分布在文件系统的哪些页（磁盘扇区组）。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页可能也不连
续。
在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。
在内存页与磁盘上的文件系统页之间建立映射。
为每一个内存页产生页错误。
虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。
一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。
文件系统数据也会进行高速缓存，大多数操作系统假设进程会继续读取文件剩余部分，因而会预读额外的文件系统页。

类似的步骤在写文件数据时也会采用。这时，文件内容的改变（通过write( )）将导致文件系统页变脏，随后通过页面调出，与磁盘上的
文件内容保持同步。文件的创建方式是，先把文件映射到空闲文件系统页，在随后的写操作中，再将文件系统页刷新到磁盘。

内存映射文件：
内存映射 I/O 使用文件系统建立从用户空间直到可用文件系统页的虚拟内存映射。好处有：
用户进程把文件数据当作内存，所以无需发布 read( ) 或write( ) 系统调用。
当用户进程碰触到映射内存空间，页错误会自动产生，从而将文件数据从磁盘读进内存。如果用户修改了映射内存空间，相关页会自动标记为脏，随后刷新到磁盘，文件得到更新。
操作系统的虚拟内存子系统会对页进行智能高速缓存，自动根据系统负载进行内存管理。
数据总是按页对齐的，无需执行缓冲区拷贝。
大型文件使用映射，无需耗费大量内存，即可进行数据拷贝。
如果数据缓冲区是按页对齐的，且大小是内建页大小的倍数，那么，对大多数操作系统而言，其处理效率会大幅提升。

文件锁定
文件锁定机制允许一个进程阻止其他进程存取某文件，或限制其存取方式。通常的用途是控制共享信息的更新方式，或用于事务隔离。在
控制多个实体并行访问共同资源方面，文件锁定是必不可少的。

文件锁定可以细致到单个字节。锁定与特定文件相关，开始于文件的某个特定字节地址，包含特定数量的连续字节。这对于协调多个进程
互不影响地访问文件不同区域，是至关重要的。

文件锁定有两种方式：共享的和独占的。多个共享锁可同时对同一文件区域发生作用；独占锁则不同，它要求相关区域不能有其他锁定在
起作用。

流I/O

流I/O模仿了通道，必须顺序存取。
非块模式：多数操作系统允许把流置于非块模式，这样，进程可以查看流上是否有输入，这使得进程可以在有输入的时候进行处理，输入
流闲置时执行其他功能。
就绪性选择：就绪性选择与非块模式类似，但是把查看流是否就绪的任务交给了操作系统。操作系统受命查看一序列流，并提醒进程哪些
流已经就绪。凭借操作系统返回的就绪信息，进程就可以使用相同代码和单一线程，实现多活动流的多路传输。

PS:DMA(http://www.nbrkb.net/lwt/jsjsj/asm/INTR&DMA.htm)
直接内存存取（DMA）方式 
　　直接内存存取技术是指，数据在内存与I/O设备间直接进行成块传输。 
　　DMA技术特征 
　　DMA有两个技术特征，首先是直接传送，其次是块传送。 
　　所谓直接传送，即在内存与IO设备间传送一个数据块的过程中，不需要CPU的任何中间干涉，只需要CPU在过程开始时向设备发出“传送
　　块
　　数据”的命令，然后通过中断来得知过程是否结束和下次操作是否准备就绪。 
　　
　　DMA工作过程： 
　　⑴当进程要求设备输入数据时，CPU把准备存放输入数据的内存起始地址以及要传送的字节数分别送入DMA控制器中的内存地址寄存器
　　和
　　传送字节计数器。
　　⑵发出数据传输要求的进行进入等待状态。此时正在执行的CPU指令被暂时挂起。进程调度程序调度其他进程占据CPU。
　　⑶输入设备不断地窃取CPU工作周期，将数据缓冲寄存器中的数据源源不断地写入内存，直到所要求的字节全部传送完毕。
　　⑷DMA控制器在传送完所有字节时，通过中断请求线发出中断信号。CPU在接收到中断信号后，转入中断处理程序进行后续处理。
　　⑸中断处理结束后，CPU返回到被中断的进程中，或切换到新的进程上下文环境中，继续执行。
　　
　　DMA与中断的区别：
　　⑴中断方式是在数据缓冲寄存器满之后发出中断，要求CPU进行中断处理，而DMA方式则是在所要求传送的数据块全部传送结束时要求CPU 
　　进行中断处理。这就大大减少了CPU进行中断处理的次数。
　　⑵中断方式的数据传送是在中断处理时由CPU控制完成的，而DMA方式则是在DMA控制器的控制下，不经过CPU控制完成的。这就排除了CPU
　　因并行设备过多而来不及处理以及因速度不匹配而造成数据丢失等现象。
　　
　　DMA方式的优缺点：
　　在DMA方式中，由于I/O设备直接同内存发生成块的数据交换，因此I/O效率比较高。由于DMA技术可以提高I/O效率，因此在现代计算机
　　系统中，得到了广泛的应用。许多输入输出设备的控制器，特别是块设备的控制器，都支持DMA方式。
　　通过上述分析可以看出，DMA控制器功能的强弱，是决定DMA效率的关键因素。DMA控制器需要为每次数据传送做大量的工作，数据传送单
　　位的增大意味着传送次数的减少。另外，DMA方式窃取了始终周期，CPU处理效率降低了，要想尽量少地窃取始终周期，就要设法提高
　　DMA控制器的性能，这样可以较少地影响CPU出理效率。
　　
　　
　　
