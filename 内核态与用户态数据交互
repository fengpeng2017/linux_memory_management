
原文出自http://www.blogbus.com/wanderer-zjhit-logs/151138377.html
《数据在内核态和用户态传输--分析copy_from_user - [linux内核]》

1 用户一般的数据操作只能在用户态进行;要操作内核态数据，必须利用标准的接口实现。
   有很多方法可以读取或者修改内核态的数据。
   1.1 可以利用动态模块，向用户态一样操作核心态数据结构
   1.2 可以利用标准的系统调用、添加的系统调用来操作核心态数据
   1.3 利用procfs读取、写入核心态数据 [sysctl系统调用]
   1.4 利用sysfs读取、写入核心态数据
   1.5 利用seq_file接口操作核心态数据 [自己添加内核操作方法]
   1.6 利用kprobe、jprobe、jretprobe调试技术操作核心态数据
   1.7 利用netlink钩子函数操作核心态数据结构
   1.8 利用访问设备文件的方式操作核心态数据结构
   .....
2  内核态和用户态区别
   内核态的出现源于保护模式，从本质上讲linux系统不相信用户、也不认为用户有能力能很好的利用os所提供 
   的强大的资源管理能力。为此OS运行在与用户隔离的空间中，运行级别为0，所有进程的内核态数据空间都是一样
   的，因为那里跑的是操作系统的代码，执行基本的资源管理任务，线性地址空间位于oxc000 0000以上，
   内存映射方式为：实际内存=线性内存-3G；用户态属于每个进程的私有空间[这也是进程间会有差别的原因]，我
   们一 般打交道使用的空间都是用户空间，用户空间的管理依靠于task_strut的mm内存管理单元，其将内存划分
   为若干内存区域(vm_area_struct),然后依靠页表来管理这些上述的内存区域，用户空间是可以被内存交换换进换
   出的，而内核空间显然不能被换出...
3 内核态用户态交互的接口
   1 中描述了大量的内核态交互方法，这好比linux系统的底层不同文件系统的访问[其在vfs层总是归结于同一系统
   调用read和write操作]。内核数据交互也是类似，不过与fs访问正好相反，上面大量的交互方式都归结于下面两个
   最基本的函数[copy_from_user和copy_to_user]。所以摁其咽喉，方能掌握本质，分析分析copy_from_user


在cpu进行访址的时候，内核空间和用户空间使用的都是线性地址，cpu在访址的过程中会自动完成从线性地址到物理地址的转换[用户态、
内核态都得依靠进程页表完成转换]，而合理的线性地址意味着：该线性地址位于该进程task_struct->mm虚存空间的某一段vm_struct_mm中，而且建立线性地址到物理地址的映射，即线性地址对应内容在物理内存中。如果访存失败，有两种可能：该线性地址存在在进程虚存区间中，但是并未建立于物理内存的映射，有可能是交换出去，也有可能是刚申请到线性区间[内核是很会偷懒的]，要依靠缺页异常去建立申请物理空间并建立映射；第2种可能是线性地址空间根本没有在进程虚存区间中，这样就会出现常见的坏指针，就会引发常见的段错误[也有可能由于访问了无权访问的空间造成保护异常]。如果坏指针问题发生在用户态，最严重的就是杀死进程[最常见的就是在打dota时候出现的大红X，然后dota程序结束]，如果发生在内核态,整个系统可能崩溃[xp的蓝屏很可能就是这种原因形成的]。所以linux当然不会任由这种情况的发生，其措施如下：
linux内核对于可能发生问题的指令都会准备"修复地址"，而且遵循谁使用这些指令，谁负责修复工作的原则。
